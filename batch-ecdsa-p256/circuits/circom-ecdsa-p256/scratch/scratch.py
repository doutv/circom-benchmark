import math

# import sys
# sys.path.append('/Users/jbel/circom-ecdsa-p256/scripts')
# from compute_p256_math import get_long
# all signals in circom are taken mod this 254-bit prime
babyjubjub_prime = (
    21888242871839275222246405745257275088548364400416034343698204186575808495617
)

# size of the base field of p256 curve
P = 115792089210356248762697446949407573530086143415290314195533631308867097853951

# 32-bit register numbers (with overflow)


def mod_p(n):
    return n % P


def get_long(n, k, x):
    ret = []
    for idx in range(k):
        ret.append(x % (2**n))
        x = x // (2**n)
    return ret


print(f"p in (32,8) representation = {get_long(32, 8, P)}")


def get_short(num, n):
    result = 0
    for i in range(len(num)):
        result += num[i] * (2 ** (n * i))
    return result


prime_reduce_coeffs = [
    [1, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [1, 0, 0, 4294967295, 4294967295, 4294967295, 4294967294, 0],
    [4294967295, 0, 1, 1, 4294967295, 4294967294, 0, 4294967294],
    [4294967294, 4294967294, 4294967295, 2, 2, 0, 1, 4294967294],
    [4294967295, 4294967294, 4294967294, 4294967295, 0, 2, 3, 0],
    [3, 0, 4294967295, 4294967291, 4294967294, 4294967295, 4294967293, 4],
    [2, 5, 3, 4294967294, 4294967289, 4294967291, 4294967292, 4294967292],
]


def prime_reduce(input):
    out = [0] * 8
    for i in range(8):
        for j in range(10):
            out[i] += prime_reduce_coeffs[j][i] * input[j]
    return out


# (n,k) = (64,10)
circuit_input = [
    5477309056849665717288716933014530289923633976480703436866,
    7994216246134738029693926913849331298100776613932837736787,
    20597098804255160793536094346835435858891034312844008526976,
    24081142476053152383489765775694493403995489760583505812692,
    27942342172107885265743448700002544394917721576194116489877,
    24596188685839422727699595064634599767343330143182270193146,
    16023950495310598602403058560280021190668293464541717344875,
    8969210184645150594009334345186397937285283576086984532980,
    3202027368135246498762305357242428206209218255498458103798,
    459539768467051557235386925911389314767911436845848222743,
]
input_w_negs = circuit_input


print(
    f"am i going crazy: {(babyjubjub_prime * (2**(64*5) + 2**(64*6) + 2**(64*7))) % P == 0}"
)

# input_w_negs = [
#     4292955422453145964822479413621913075509602355677488716324,
#     14138856352885911993756608258123408875015425226836977408445,
#     19152084246042552967396910108811035673348399945778457592706,
#     12217327447688951856114508225080847269707233820600705128337,
#     1256809376368187748897015378026120801835577723245181144683,
#     -5357144585194727522208286995229502672918395199066236896292,
#     -5701009903066879220160354445995883352949269859399558567664,
#     -1857735208184233489713766934499120265226159210590079992716,
#     923200339955551664594468325804491929844512499798227728984,
#     661957230541661508833462765560680486656693245077732287604,
# ]


# def check_prime_reduce(negs):
#     if negs:
#         input_used = input_w_negs
#     else:
#         input_used = input
#     prime_reduce_out = prime_reduce(input_used)
#     prime_reduce_circuit_short = get_short(prime_reduce_out, 32)
#     print(f"prime reduce python output = {prime_reduce_out}")
#     in_short = get_short(input_used, 64)
#     # only true with negative inputs (yeah that's expected)
#     print(f"input is a multiple of P? {in_short % P == 0}")

#     print(
#         f"python prime reduce congruent to input mod P? {((prime_reduce_circuit_short - in_short) % P) == 0}"
#     )


# check_prime_reduce(True)


# (n,k) = (32, 8)
circuit_prime_reduce_out = [
    212984633734340117457950005240404110997764362411455218235427886251043,
    107344807696394443008193267451432838599413561113649140947292848988085,
    121097410567925527747491283184918165818408843075108549773998103103817,
    174260221323464569417405159296157643949761220910431163705143072183371,
    241377582909071380053420916522157321980790853004028240516166397985850,
    241377582853889718847064786597367263348198777706772897412420808191222,
    135737756906344003311852332811587327479264066512141530003054698440115,
    176435877548514631810737913768421906383243055684255327039735124422322,
]

expected_prime_reduce_out = prime_reduce(circuit_input)

print(
    f"circuit computed prime reduce out correctly? {circuit_prime_reduce_out == expected_prime_reduce_out}"
)


# after adding large multiple of p (i.e. should be positive)
# (n,k) = (32, 8)
circuit_reduced = [
    55426955395203346062864074699120910991877335319596923709273278994234403,
    55321315569165400388414317961331939719478984518299117631985143956971445,
    55335068172036931473153615977065425046697979800260577040811849211087177,
    174260221323464569417405159296157643949761220910431163705143072183371,
    241377582909071380053420916522157321980790853004028240516166397985850,
    241377582853889718847064786597367263348198777706772897412420808191222,
    135737769761848357383774537147284066208564886689765480265397380851123,
    55390406639017520577216862607648928787262814012869723818077586232405682,
]

circuit_prime_reduce_out_bigint = get_short(circuit_prime_reduce_out, 32)
circuit_reduced_bigint = get_short(circuit_reduced, 32)
print(
    f"circuit reduced is congruent to output of prime_reduce mod P? {(circuit_prime_reduce_out_bigint-circuit_reduced_bigint) % P == 0}"
)

# (n,k) = (32, 16)
circuit_proper = [
    1546435619,
    2297931848,
    4168434873,
    3647777780,
    2206504338,
    14694086,
    1298502331,
    845341814,
    167700765,
    175910939,
    1495087567,
    1703443683,
    2767007255,
    2338051116,
    2054,
    0,
]

expected_proper = get_long(32, 16, get_short(circuit_reduced, 32))
print(
    f"circuit computed proper of reduced correctly? {expected_proper == circuit_proper}"
)

circuit_q = [2125042186, 860905375, 860478079, 175481588, 810091076, 2338053171, 2054]

# expected_q_literal = [0, 0, 0, 0, 813694976, 2338053171, 2054]

expected_q_short = int(get_short(circuit_proper, 32) / P)
expected_q_long = get_long(32, 7, expected_q_short)
print(f"expected q = {expected_q_long}")
print(f"circuit computed q := proper/P correctly? {circuit_q == expected_q_long}")

# (n,k) = (32, 14)
# even with correct q and qpprod, entire circuit still failing?
circuit_qpProd_with_correct_q = [
    0,
    0,
    0,
    0,
    3494793310025809920,
    13536655213441852365,
    13536664035304676295,
    10041870725278866375,
    8821862823930,
    0,
    813694976,
    3494793312363863091,
    10041861903416044499,
    8821862823930,
]

circuit_qpProd_with_incorrect_q = [
    9126986689365306870,
    12824547119080017495,
    16520272326449443800,
    8146973318418801390,
    7928727566095450185,
    14274864262142066325,
    13521185404795267981,
    19168857415505078620,
    3697569252438012634,
    3695725207544907893,
    753687682144755536,
    3479314679729412591,
    10041861903416044499,
    8821862823930,
]

circuit_qpProd_with_correct_q_bigint = get_short(circuit_qpProd_with_correct_q, 32)
print(
    f"circuit qpprod = q*p? {circuit_qpProd_with_correct_q_bigint == expected_q_short*P}"
)
# so product is correct, just computation of q is failing
21888187444883880018900342881182575967637372523080714746774494913296814261214
21888187550523706056846017330939313756608644921431516044580572201431851524172
21888187536771103185314932591641298023123317702436234083121163374726597408440
21888242697579053898781836327852115792390720450654813433267040481432736312246
21888242630461692313175025691836358566391042419625181339673458463719436319687
21888242630461692368356686898192488491181101052217256636938843429368442156760
21888242736101505460398048361482737941264298191851147653946260585213732320789
21888187481432636204725828528394667439619577137602021473984427979714854956310
8821862823930
0
813694976
3494793312363863091
10041861903416044499
